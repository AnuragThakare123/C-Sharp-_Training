Task 1:

1. Use a Nested List to store readings of one meter for a week, 7 days 3 time slots like Morning, Afternoon, Night.
2. Use a Nested Dictionary to store readings of multiple Areas - Houses - Daily readings.
3. Use a Dictionary with List to store Area Name - List of meters in that area.
4. Use a List of Dictionary to store a list of complaints where each complaint has fields like- Housenumber/MeterNum, Issue and Date.

Write a program to:
• Print the Night reading of Day 3 for a particular meter from Nested List.
• Print all readings of a specific house from Nested Dictionary.
• Print all meters in a given area from Dictionary of List.
• Print all complaints from List of Dictionary.


using System;
us
ing System.Collections.Generic;

class Program
{
    static void Main()
    {
        // 1. Nested List: Meter readings for 7 days (3 slots per day)
    
        List<List<int>> meterReadings = new List<List<int>>()
        {
            new List<int>{10, 15, 20},   // Day 1
            new List<int>{12, 16, 22},   // Day 2
            new List<int>{14, 18, 25},   // Day 3
            new List<int>{11, 15, 21},   // Day 4
            new List<int>{13, 17, 23},   // Day 5
            new List<int>{15, 19, 27},   // Day 6
            new List<int>{16, 20, 28}    // Day 7
        };

        // Print Night reading of Day 3
        Console.WriteLine("Night Reading of Day 3: " + meterReadings[2][2]);


        // 2. Nested Dictionary -> to store Area - House - Daily reading
        var areaReadings = new Dictionary<string, Dictionary<string, List<int>>>()
        {
            { "Area1", new Dictionary<string, List<int>>()
                {
                    { "House1", new List<int>{100,120,110,115,118,122,119} },
                    { "House2", new List<int>{90,95,100,105,102,101,99} }
                }
            },
            { "Area2", new Dictionary<string, List<int>>()
                {
                    { "House3", new List<int>{130,135,138,140,142,145,150} },
                    { "House4", new List<int>{80,85,87,90,88,86,89} }
                }
            }
        };

        // Print all readings of House3
        Console.WriteLine("\nAll Readings of House3: " + string.Join(", ", areaReadings["Area2"]["House3"]));


        // 3. Dictionary with List 
        
        var areaMeters = new Dictionary<string, List<string>>()
        {
            { "Area1", new List<string>{ "MTR101", "MTR102", "MTR103" } },
            { "Area2", new List<string>{ "MTR201", "MTR202" } },
            { "Area3", new List<string>{ "MTR301", "MTR302", "MTR303", "MTR304" } }
        };

        // Print all meters in Area2
        Console.WriteLine("\nMeters in Area2: " + string.Join(", ", areaMeters["Area2"]));


        // 4. List of Dictionary → Complaints List
        var complaints = new List<Dictionary<string, string>>()
        {
            new Dictionary<string, string>()
            {
                {"HouseNumber", "H101"},
                {"MeterNumber", "MTR101"},
                {"Issue", "Meter not working"},
                {"Date", "2025-08-20"}
            },
            new Dictionary<string, string>()
            {
                {"HouseNumber", "H202"},
                {"MeterNumber", "MTR202"},
                {"Issue", "High reading"},
                {"Date", "2025-08-21"}
            }
        };

        // Print all complaints
        Console.WriteLine("\nComplaints List:");
        foreach (var complaint in complaints)
        {
            Console.WriteLine($"House: {complaint["HouseNumber"]}, Meter: {complaint["MeterNumber"]}, Issue: {complaint["Issue"]}, Date: {complaint["Date"]}");
        }
    }
}
----------------------***--------------
using System;
using System.Collections.Generic;

#region ENUM
// 1. Enum
enum MeterStatus { Active, Inactive, Fault }
#endregion

#region STRUCT
// 2. Struct
struct Reading
{
    public DateTime Date { get; }
    public int Units { get; }

    public Reading(DateTime date, int units)
    {
        Date = date;
        Units = units;
    }
}
#endregion

#region ABSTRACT CLASS
// 3. Abstract Class and Inheritance
abstract class Notifier
{
    public abstract void SendMessage(string msg);
}

class SmsNotifier : Notifier
{
    private string phone;
    public SmsNotifier(string phone) { this.phone = phone; }
    public override void SendMessage(string msg)
    {
        Console.WriteLine($"[SMS to {phone}] {msg}");
    }
}

class EmailNotifier : Notifier
{
    private string email;
    public EmailNotifier(string email) { this.email = email; }
    public override void SendMessage(string msg)
    {
        Console.WriteLine($"[Email to {email}] {msg}");
    }
}
#endregion

#region STATIC CLASS
// 6. Static Class
static class Tariff
{
    public static double RatePerUnit = 5.0;
}
#endregion

#region SEALED CLASS
// 7. Sealed Class
sealed class BillCalculator
{
    public double CalculateBill(List<Reading> readings)
    {
        int totalUnits = 0;
        foreach (var r in readings)
            totalUnits += r.Units;

        return totalUnits * Tariff.RatePerUnit;
    }
}
#endregion

#region PARTIAL CLASS
// 8. Partial Class
partial class Customer
{
    public string Name { get; set; }
    public string? Email { get; set; }  // Nullable
}

partial class Customer
{
    public string? Phone { get; set; }

    // Pick email if present, otherwise fallback to phone
    public string GetContact() => Email ?? Phone ?? "No contact available";
}
#endregion

#region METER + NESTED CLASS + EVENT
// 9. Nested Class + Event
class Meter
{
    public string MeterId { get; }
    public MeterStatus Status { get; set; }

    public Meter(string meterId, MeterStatus status)
    {
        MeterId = meterId;
        Status = status;
        History = new ReadingHistory();
    }

    // Nested class: ReadingHistory
    public class ReadingHistory
    {
        private List<Reading> readings = new List<Reading>();
        public IReadOnlyList<Reading> Readings => readings.AsReadOnly();

        public void AddReading(Reading r) => readings.Add(r);
    }

    public ReadingHistory History { get; }

    // 4. Event
    public event Action<Reading>? NewReadingAdded;

    public void AddReading(Reading r)
    {
        History.AddReading(r);
        // Trigger event
        NewReadingAdded?.Invoke(r);
    }
}
#endregion

class Program
{
    static void Main()
    {
        // 1) Create a Customer with only phone
        Customer customer1 = new Customer { Name = "Raj", Phone = "9876543210" };

        // Or only email
        Customer customer2 = new Customer { Name = "Anita", Email = "anita@example.com" };

        Console.WriteLine($"Customer1 Contact: {customer1.GetContact()}");
        Console.WriteLine($"Customer2 Contact: {customer2.GetContact()}");

        // 2) Create a meter
        Meter meter = new Meter("MTR101", MeterStatus.Active);

        // 3) Setup Notifier depending on available contact
        Notifier notifier = (customer1.Email != null)
            ? new EmailNotifier(customer1.Email)
            : new SmsNotifier(customer1.Phone ?? "Unknown");

        // Subscribe to event
        meter.NewReadingAdded += (reading) =>
        {
            notifier.SendMessage($"New reading added: {reading.Units} units on {reading.Date:d}");
        };

        // 4) Add readings (this will trigger event)
        meter.AddReading(new Reading(DateTime.Now, 50));
        meter.AddReading(new Reading(DateTime.Now.AddDays(1), 30));

        // 5) Generate Bill
        BillCalculator calc = new BillCalculator();
        double bill = calc.CalculateBill(new List<Reading>(meter.History.Readings));
        Console.WriteLine($"\nBill for Meter {meter.MeterId}: ₹{bill}");
    }
}







